-- Safe User Payment System Setup
-- This version handles existing policies and tables safely
-- Run this in Supabase SQL Editor

-- 1. Create user_payment_methods table (if not exists)
CREATE TABLE IF NOT EXISTS public.user_payment_methods (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  stripe_customer_id text,
  stripe_setup_intent_id text,
  stripe_payment_method_id text,
  payment_method_type text default 'card', -- 'card', 'bank_account', 'sepa_debit'
  last_four text,
  brand text, -- 'visa', 'mastercard', 'bank_account'
  is_default boolean default false,
  is_active boolean default true,
  metadata jsonb default '{}',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add unique constraint if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'user_payment_methods_user_id_stripe_payment_method_id_key'
    ) THEN
        ALTER TABLE public.user_payment_methods 
        ADD CONSTRAINT user_payment_methods_user_id_stripe_payment_method_id_key 
        UNIQUE(user_id, stripe_payment_method_id);
    END IF;
END $$;

-- 2. Enable RLS
ALTER TABLE public.user_payment_methods ENABLE ROW LEVEL SECURITY;

-- 3. Drop and recreate RLS policies (safe approach)
DROP POLICY IF EXISTS "Users can view own payment methods" ON public.user_payment_methods;
DROP POLICY IF EXISTS "Users can insert own payment methods" ON public.user_payment_methods;
DROP POLICY IF EXISTS "Users can update own payment methods" ON public.user_payment_methods;
DROP POLICY IF EXISTS "Users can delete own payment methods" ON public.user_payment_methods;
DROP POLICY IF EXISTS "Admins can view all payment methods" ON public.user_payment_methods;

CREATE POLICY "Users can view own payment methods" ON public.user_payment_methods
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own payment methods" ON public.user_payment_methods
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own payment methods" ON public.user_payment_methods
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own payment methods" ON public.user_payment_methods
  FOR DELETE USING (auth.uid() = user_id);

-- Simplified admin policy (without custom authorize function for now)
CREATE POLICY "Admins can view all payment methods" ON public.user_payment_methods
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.user_roles 
      WHERE user_roles.user_id = auth.uid() 
      AND user_roles.role = 'admin'
    )
  );

-- 4. Create indexes for performance (if not exists)
CREATE INDEX IF NOT EXISTS idx_user_payment_methods_user_id ON public.user_payment_methods(user_id);
CREATE INDEX IF NOT EXISTS idx_user_payment_methods_stripe_customer ON public.user_payment_methods(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_user_payment_methods_default ON public.user_payment_methods(user_id, is_default) WHERE is_default = true;

-- 5. Create or replace trigger for updated_at
DROP TRIGGER IF EXISTS update_user_payment_methods_updated_at ON public.user_payment_methods;

-- First ensure the function exists
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_user_payment_methods_updated_at
  BEFORE UPDATE ON public.user_payment_methods
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- 6. Create user_stripe_accounts table for sellers (Stripe Connect)
CREATE TABLE IF NOT EXISTS public.user_stripe_accounts (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  stripe_account_id text,
  account_status text default 'pending', -- 'pending', 'active', 'restricted', 'inactive'
  details_submitted boolean default false,
  charges_enabled boolean default false,
  payouts_enabled boolean default false,
  requirements jsonb default '{}',
  capabilities jsonb default '{}',
  metadata jsonb default '{}',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add constraints if they don't exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'user_stripe_accounts_user_id_key'
    ) THEN
        ALTER TABLE public.user_stripe_accounts 
        ADD CONSTRAINT user_stripe_accounts_user_id_key UNIQUE(user_id);
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'user_stripe_accounts_stripe_account_id_key'
    ) THEN
        ALTER TABLE public.user_stripe_accounts 
        ADD CONSTRAINT user_stripe_accounts_stripe_account_id_key UNIQUE(stripe_account_id);
    END IF;
END $$;

-- 7. Enable RLS on user_stripe_accounts
ALTER TABLE public.user_stripe_accounts ENABLE ROW LEVEL SECURITY;

-- 8. Drop and recreate RLS policies for Stripe accounts
DROP POLICY IF EXISTS "Users can view own stripe account" ON public.user_stripe_accounts;
DROP POLICY IF EXISTS "Users can update own stripe account" ON public.user_stripe_accounts;
DROP POLICY IF EXISTS "Sellers can create stripe accounts" ON public.user_stripe_accounts;
DROP POLICY IF EXISTS "Admins can view all stripe accounts" ON public.user_stripe_accounts;

CREATE POLICY "Users can view own stripe account" ON public.user_stripe_accounts
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own stripe account" ON public.user_stripe_accounts
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Sellers can create stripe accounts" ON public.user_stripe_accounts
  FOR INSERT WITH CHECK (
    auth.uid() = user_id AND
    EXISTS (
      SELECT 1 FROM public.user_roles 
      WHERE user_roles.user_id = auth.uid() 
      AND user_roles.role IN ('seller', 'admin')
    )
  );

CREATE POLICY "Admins can view all stripe accounts" ON public.user_stripe_accounts
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.user_roles 
      WHERE user_roles.user_id = auth.uid() 
      AND user_roles.role = 'admin'
    )
  );

-- 9. Create indexes (if not exists)
CREATE INDEX IF NOT EXISTS idx_user_stripe_accounts_user_id ON public.user_stripe_accounts(user_id);
CREATE INDEX IF NOT EXISTS idx_user_stripe_accounts_stripe_id ON public.user_stripe_accounts(stripe_account_id);
CREATE INDEX IF NOT EXISTS idx_user_stripe_accounts_status ON public.user_stripe_accounts(account_status);

-- 10. Create trigger for updated_at
DROP TRIGGER IF EXISTS update_user_stripe_accounts_updated_at ON public.user_stripe_accounts;

CREATE TRIGGER update_user_stripe_accounts_updated_at
  BEFORE UPDATE ON public.user_stripe_accounts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- 11. Grant necessary permissions for API access
DO $$
BEGIN
    -- Grant permissions to authenticated users
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.user_payment_methods TO authenticated;
    GRANT SELECT, INSERT, UPDATE ON public.user_stripe_accounts TO authenticated;
    
    -- Grant usage on sequences
    GRANT USAGE ON SEQUENCE public.user_payment_methods_id_seq TO authenticated;
    GRANT USAGE ON SEQUENCE public.user_stripe_accounts_id_seq TO authenticated;
    
EXCEPTION
    WHEN insufficient_privilege THEN
        RAISE NOTICE 'Permissions already granted or insufficient privileges';
END $$;

SELECT 'User payment methods and Stripe Connect tables safely created/updated!' as result;
